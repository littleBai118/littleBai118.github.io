const e=JSON.parse('{"key":"v-1d6328b1","path":"/juc/JUC.html","title":"JUC——Java并发编程","lang":"zh-CN","frontmatter":{"title":"JUC——Java并发编程","date":"2023-05-15T11:20:49.000Z","category":["JUC"],"tag":["JUC"],"description":"进程与线程 进程 程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理IO的。当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。 进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器等)，也有的程序只能启动一个实例进程（例如网易云音乐、360安全卫士等)。 线程 一个进程之内可以分为一到多个线程。 一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给CPU执行 Java中，线程作为最小调度单位，进程作为资源分配的最小单位。在windows 中进程是不活动的，只是作为线程的容器。","head":[["meta",{"property":"og:url","content":"https://littlebai118.github.io/juc/JUC.html"}],["meta",{"property":"og:site_name","content":"白先生"}],["meta",{"property":"og:title","content":"JUC——Java并发编程"}],["meta",{"property":"og:description","content":"进程与线程 进程 程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理IO的。当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。 进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器等)，也有的程序只能启动一个实例进程（例如网易云音乐、360安全卫士等)。 线程 一个进程之内可以分为一到多个线程。 一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给CPU执行 Java中，线程作为最小调度单位，进程作为资源分配的最小单位。在windows 中进程是不活动的，只是作为线程的容器。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://littlebai118.github.io/"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-05-15T03:21:09.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"JUC——Java并发编程"}],["meta",{"property":"article:tag","content":"JUC"}],["meta",{"property":"article:published_time","content":"2023-05-15T11:20:49.000Z"}],["meta",{"property":"article:modified_time","content":"2023-05-15T03:21:09.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JUC——Java并发编程\\",\\"image\\":[\\"https://littlebai118.github.io/\\"],\\"datePublished\\":\\"2023-05-15T11:20:49.000Z\\",\\"dateModified\\":\\"2023-05-15T03:21:09.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"进程与线程","slug":"进程与线程","link":"#进程与线程","children":[{"level":3,"title":"进程","slug":"进程","link":"#进程","children":[]},{"level":3,"title":"线程","slug":"线程","link":"#线程","children":[]},{"level":3,"title":"进程和线程对比","slug":"进程和线程对比","link":"#进程和线程对比","children":[]},{"level":3,"title":"并发","slug":"并发","link":"#并发","children":[]},{"level":3,"title":"并行","slug":"并行","link":"#并行","children":[]},{"level":3,"title":"同步与异步","slug":"同步与异步","link":"#同步与异步","children":[]}]},{"level":2,"title":"线程基础知识","slug":"线程基础知识","link":"#线程基础知识","children":[{"level":3,"title":"线程的创建","slug":"线程的创建","link":"#线程的创建","children":[]},{"level":3,"title":"线程上下文切换（Thread Context Switch)","slug":"线程上下文切换-thread-context-switch","link":"#线程上下文切换-thread-context-switch","children":[]},{"level":3,"title":"Start和Run方法","slug":"start和run方法","link":"#start和run方法","children":[]},{"level":3,"title":"Sleep方法","slug":"sleep方法","link":"#sleep方法","children":[]},{"level":3,"title":"Yield方法","slug":"yield方法","link":"#yield方法","children":[]},{"level":3,"title":"线程优先级","slug":"线程优先级","link":"#线程优先级","children":[]},{"level":3,"title":"Join方法","slug":"join方法","link":"#join方法","children":[]},{"level":3,"title":"Interrupt方法","slug":"interrupt方法","link":"#interrupt方法","children":[]},{"level":3,"title":"守护线程","slug":"守护线程","link":"#守护线程","children":[]},{"level":3,"title":"线程状态","slug":"线程状态","link":"#线程状态","children":[]}]},{"level":2,"title":"共享模型之管程","slug":"共享模型之管程","link":"#共享模型之管程","children":[{"level":3,"title":"Synchronized","slug":"synchronized","link":"#synchronized","children":[]},{"level":3,"title":"变量的线程安全分析","slug":"变量的线程安全分析","link":"#变量的线程安全分析","children":[]},{"level":3,"title":"线程安全的类","slug":"线程安全的类","link":"#线程安全的类","children":[]},{"level":3,"title":"Synchronized底层原理","slug":"synchronized底层原理","link":"#synchronized底层原理","children":[]},{"level":3,"title":"Wait/Notify","slug":"wait-notify","link":"#wait-notify","children":[]},{"level":3,"title":"Park/Unpark","slug":"park-unpark","link":"#park-unpark","children":[]},{"level":3,"title":"死锁","slug":"死锁","link":"#死锁","children":[]},{"level":3,"title":"活锁","slug":"活锁","link":"#活锁","children":[]},{"level":3,"title":"定位检测死锁","slug":"定位检测死锁","link":"#定位检测死锁","children":[]},{"level":3,"title":"ReentrantLock","slug":"reentrantlock","link":"#reentrantlock","children":[]}]},{"level":2,"title":"共享模型之内存","slug":"共享模型之内存","link":"#共享模型之内存","children":[{"level":3,"title":"Java内存模型","slug":"java内存模型","link":"#java内存模型","children":[]},{"level":3,"title":"Volatile","slug":"volatile","link":"#volatile","children":[]},{"level":3,"title":"CAS","slug":"cas","link":"#cas","children":[]}]},{"level":2,"title":"线程池","slug":"线程池","link":"#线程池","children":[{"level":3,"title":"为什么要使用线程池","slug":"为什么要使用线程池","link":"#为什么要使用线程池","children":[]},{"level":3,"title":"线程池中的线程","slug":"线程池中的线程","link":"#线程池中的线程","children":[]},{"level":3,"title":"创建线程池的方式","slug":"创建线程池的方式","link":"#创建线程池的方式","children":[]},{"level":3,"title":"线程池状态","slug":"线程池状态","link":"#线程池状态","children":[]},{"level":3,"title":"线程池的饱和策略","slug":"线程池的饱和策略","link":"#线程池的饱和策略","children":[]},{"level":3,"title":"线程池的任务处理流程","slug":"线程池的任务处理流程","link":"#线程池的任务处理流程","children":[]}]},{"level":2,"title":"ThreadLocal","slug":"threadlocal","link":"#threadlocal","children":[{"level":3,"title":"原理","slug":"原理","link":"#原理","children":[]},{"level":3,"title":"ThreadLocal的内存泄露风险","slug":"threadlocal的内存泄露风险","link":"#threadlocal的内存泄露风险","children":[]},{"level":3,"title":"使用场景","slug":"使用场景","link":"#使用场景","children":[]}]},{"level":2,"title":"AQS","slug":"aqs","link":"#aqs","children":[]}],"git":{"createdTime":1684116873000,"updatedTime":1684120869000,"contributors":[{"name":"baixuanyu","email":"baixy118@163.com","commits":2}]},"readingTime":{"minutes":33.26,"words":9978},"filePathRelative":"juc/JUC.md","localizedDate":"2023年5月15日","excerpt":"<h2> 进程与线程</h2>\\n<h3> 进程</h3>\\n<p>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理IO的。当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。\\n进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器等)，也有的程序只能启动一个实例进程（例如网易云音乐、360安全卫士等)。</p>\\n<h3> 线程</h3>\\n<p>一个进程之内可以分为一到多个线程。\\n一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给CPU执行\\nJava中，线程作为最小调度单位，进程作为资源分配的最小单位。在windows 中进程是不活动的，只是作为线程的容器。</p>","autoDesc":true}');export{e as data};
