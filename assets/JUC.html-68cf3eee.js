const l=JSON.parse('{"key":"v-1d6328b1","path":"/juc/JUC.html","title":"JUC——Java并发编程","lang":"zh-CN","frontmatter":{"title":"JUC——Java并发编程","date":"2023-05-15T10:13:49.000Z","category":["JUC"],"tag":["JUC"],"description":"进程与线程 进程 程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理IO的。当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。 进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器等)，也有的程序只能启动一个实例进程（例如网易云音乐、360安全卫士等)。 线程 一个进程之内可以分为一到多个线程。 一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给CPU执行 Java中，线程作为最小调度单位，进程作为资源分配的最小单位。在windows 中进程是不活动的，只是作为线程的容器。","head":[["meta",{"property":"og:url","content":"https://littlebai118.github.io/juc/JUC.html"}],["meta",{"property":"og:site_name","content":"白先生"}],["meta",{"property":"og:title","content":"JUC——Java并发编程"}],["meta",{"property":"og:description","content":"进程与线程 进程 程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理IO的。当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。 进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器等)，也有的程序只能启动一个实例进程（例如网易云音乐、360安全卫士等)。 线程 一个进程之内可以分为一到多个线程。 一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给CPU执行 Java中，线程作为最小调度单位，进程作为资源分配的最小单位。在windows 中进程是不活动的，只是作为线程的容器。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://littlebai118.github.io/"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-05-15T02:14:33.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"JUC——Java并发编程"}],["meta",{"property":"article:tag","content":"JUC"}],["meta",{"property":"article:published_time","content":"2023-05-15T10:13:49.000Z"}],["meta",{"property":"article:modified_time","content":"2023-05-15T02:14:33.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JUC——Java并发编程\\",\\"image\\":[\\"https://littlebai118.github.io/\\"],\\"datePublished\\":\\"2023-05-15T10:13:49.000Z\\",\\"dateModified\\":\\"2023-05-15T02:14:33.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"进程","slug":"进程","link":"#进程","children":[]},{"level":2,"title":"线程","slug":"线程","link":"#线程","children":[]},{"level":2,"title":"进程和线程对比","slug":"进程和线程对比","link":"#进程和线程对比","children":[]},{"level":2,"title":"并发","slug":"并发","link":"#并发","children":[]},{"level":2,"title":"并行","slug":"并行","link":"#并行","children":[]},{"level":2,"title":"同步与异步","slug":"同步与异步","link":"#同步与异步","children":[]},{"level":2,"title":"线程的创建","slug":"线程的创建","link":"#线程的创建","children":[{"level":3,"title":"方式一（使用Thread类）","slug":"方式一-使用thread类","link":"#方式一-使用thread类","children":[]},{"level":3,"title":"方式二（使用Runnable接口）","slug":"方式二-使用runnable接口","link":"#方式二-使用runnable接口","children":[]},{"level":3,"title":"方式三（使用FutureTask）","slug":"方式三-使用futuretask","link":"#方式三-使用futuretask","children":[]}]},{"level":2,"title":"线程上下文切换（Thread Context Switch)","slug":"线程上下文切换-thread-context-switch","link":"#线程上下文切换-thread-context-switch","children":[]},{"level":2,"title":"Start和Run方法","slug":"start和run方法","link":"#start和run方法","children":[]},{"level":2,"title":"Sleep方法","slug":"sleep方法","link":"#sleep方法","children":[]},{"level":2,"title":"Yield方法","slug":"yield方法","link":"#yield方法","children":[]},{"level":2,"title":"线程优先级","slug":"线程优先级","link":"#线程优先级","children":[]},{"level":2,"title":"Join方法","slug":"join方法","link":"#join方法","children":[{"level":3,"title":"同步","slug":"同步","link":"#同步","children":[]}]},{"level":2,"title":"Interrupt方法","slug":"interrupt方法","link":"#interrupt方法","children":[{"level":3,"title":"打断被sleep、wait、join阻塞的线程","slug":"打断被sleep、wait、join阻塞的线程","link":"#打断被sleep、wait、join阻塞的线程","children":[]},{"level":3,"title":"打断正常运行的线程","slug":"打断正常运行的线程","link":"#打断正常运行的线程","children":[]},{"level":3,"title":"打断park线程","slug":"打断park线程","link":"#打断park线程","children":[]},{"level":3,"title":"JDK不推荐使用的过时方法","slug":"jdk不推荐使用的过时方法","link":"#jdk不推荐使用的过时方法","children":[]}]},{"level":2,"title":"守护线程","slug":"守护线程","link":"#守护线程","children":[]},{"level":2,"title":"线程状态","slug":"线程状态","link":"#线程状态","children":[{"level":3,"title":"操作系统层面","slug":"操作系统层面","link":"#操作系统层面","children":[]}]},{"level":2,"title":"Synchronized","slug":"synchronized","link":"#synchronized","children":[{"level":3,"title":"Synchronized代码块","slug":"synchronized代码块","link":"#synchronized代码块","children":[]},{"level":3,"title":"Synchronized方法","slug":"synchronized方法","link":"#synchronized方法","children":[]}]},{"level":2,"title":"变量的线程安全分析","slug":"变量的线程安全分析","link":"#变量的线程安全分析","children":[{"level":3,"title":"成员变量和静态变量的线程安全问题","slug":"成员变量和静态变量的线程安全问题","link":"#成员变量和静态变量的线程安全问题","children":[]},{"level":3,"title":"局部变量的线程安全问题","slug":"局部变量的线程安全问题","link":"#局部变量的线程安全问题","children":[]}]},{"level":2,"title":"线程安全的类","slug":"线程安全的类","link":"#线程安全的类","children":[]},{"level":2,"title":"Synchronized底层原理","slug":"synchronized底层原理","link":"#synchronized底层原理","children":[{"level":3,"title":"Java对象头","slug":"java对象头","link":"#java对象头","children":[]},{"level":3,"title":"Monitor","slug":"monitor","link":"#monitor","children":[]},{"level":3,"title":"轻量级锁","slug":"轻量级锁","link":"#轻量级锁","children":[]},{"level":3,"title":"锁膨胀（重量级锁）","slug":"锁膨胀-重量级锁","link":"#锁膨胀-重量级锁","children":[]},{"level":3,"title":"自旋优化","slug":"自旋优化","link":"#自旋优化","children":[]},{"level":3,"title":"偏向锁","slug":"偏向锁","link":"#偏向锁","children":[]}]},{"level":2,"title":"Wait/Notify","slug":"wait-notify","link":"#wait-notify","children":[{"level":3,"title":"Wait/Notify工作原理","slug":"wait-notify工作原理","link":"#wait-notify工作原理","children":[]},{"level":3,"title":"API介绍","slug":"api介绍","link":"#api介绍","children":[]},{"level":3,"title":"Wait和Sleep","slug":"wait和sleep","link":"#wait和sleep","children":[]}]},{"level":2,"title":"Park/Unpark","slug":"park-unpark","link":"#park-unpark","children":[]},{"level":2,"title":"死锁","slug":"死锁","link":"#死锁","children":[]},{"level":2,"title":"活锁","slug":"活锁","link":"#活锁","children":[]},{"level":2,"title":"定位检测死锁","slug":"定位检测死锁","link":"#定位检测死锁","children":[]},{"level":2,"title":"ReentrantLock","slug":"reentrantlock","link":"#reentrantlock","children":[{"level":3,"title":"可重入","slug":"可重入","link":"#可重入","children":[]},{"level":3,"title":"可打断","slug":"可打断","link":"#可打断","children":[]},{"level":3,"title":"锁超时","slug":"锁超时","link":"#锁超时","children":[]},{"level":3,"title":"公平锁","slug":"公平锁","link":"#公平锁","children":[]},{"level":3,"title":"条件变量","slug":"条件变量","link":"#条件变量","children":[]}]},{"level":2,"title":"Java内存模型","slug":"java内存模型","link":"#java内存模型","children":[{"level":3,"title":"可见性","slug":"可见性","link":"#可见性","children":[]},{"level":3,"title":"有序性","slug":"有序性","link":"#有序性","children":[]}]},{"level":2,"title":"Volatile","slug":"volatile","link":"#volatile","children":[{"level":3,"title":"Volatile原理","slug":"volatile原理","link":"#volatile原理","children":[]}]},{"level":2,"title":"CAS","slug":"cas","link":"#cas","children":[]},{"level":2,"title":"ThreadPoolExecutor","slug":"threadpoolexecutor","link":"#threadpoolexecutor","children":[{"level":3,"title":"线程池状态","slug":"线程池状态","link":"#线程池状态","children":[]},{"level":3,"title":"线程池构造方法","slug":"线程池构造方法","link":"#线程池构造方法","children":[]}]}],"git":{"createdTime":1684116873000,"updatedTime":1684116873000,"contributors":[{"name":"baixuanyu","email":"baixy118@163.com","commits":1}]},"readingTime":{"minutes":27.96,"words":8388},"filePathRelative":"juc/JUC.md","localizedDate":"2023年5月15日","excerpt":"<h1> 进程与线程</h1>\\n<h2> 进程</h2>\\n<p>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理IO的。当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。\\n进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器等)，也有的程序只能启动一个实例进程（例如网易云音乐、360安全卫士等)。</p>\\n<h2> 线程</h2>\\n<p>一个进程之内可以分为一到多个线程。\\n一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给CPU执行\\nJava中，线程作为最小调度单位，进程作为资源分配的最小单位。在windows 中进程是不活动的，只是作为线程的容器。</p>","autoDesc":true}');export{l as data};
